#!/usr/bin/env bash
set -Eeuo pipefail

self="$(basename "$0")"
usage() {
	echo "usage: $self target-dir/ foo.dsc [foo-validate-bash]"
	echo "   eg: $self my-output-dir/ https://example.com/foo.dsc \"sha256sum --strict --check <<<'deadbeefcafe *foo.dsc'\""
}
fatal_usage() {
	if [ "$#" -gt 0 ]; then
		echo >&2 "error: $*"
		echo >&2
	fi
	usage >&2
	exit 1
}
[ "$#" -ge 2 ] || fatal_usage "expected at least 2 arguments (got $#)"

targetDirectory="$1"; shift
mkdir -p "$targetDirectory"
targetDirectory="$(readlink -ev "$targetDirectory")"

dsc="$1"; shift # can also take a .changes file ðŸ‘€ (and either local path *or* remote)
dscValidate="${1:-}" # (optional) bit of bash code to validate the dsc file after downloading it (before downloading more files from it); ideally from "dsc-extract-checksums" -> "bashValidate"

if [ -e "$dsc" ]; then
	# TODO instead of just assuming that files which exist are local, we should probably check for a URL prefix like "https?://" (and then use that consistent value throughout instead of trying to wget just because things don't exist locally)
	dsc="$(readlink -ev "$dsc")"
fi
dscBase="$(basename "$dsc")"
dscDir="$(dirname "$dsc")"

_get() {
	local f="$1"; shift
	local validate="${1:-}"

	# TODO copy/download to a temporary directory instead of directly into targetDirectory so that files only end up in targetDirectory *after* they're validated
	# ... on second thought, we should download *everything* to a temporary directory first so we get all or nothing

	if [ -e "$dscDir/$f" ]; then
		cp --verbose --dereference --target-directory="$targetDirectory" "$dscDir/$f" || return 1
	else
		wget --no-verbose --output-document="$targetDirectory/$f" "$dscDir/$f" || return 1
	fi

	if [ -n "$validate" ]; then
		(
			set -Eeuo pipefail
			cd "$targetDirectory"
			eval "$validate"
		) || return 1
	fi
}

# TODO if dscDir is local, we should pre-validate all the contents

_get "$dscBase" "$dscValidate"

shell="$(dsc-extract-checksums "$targetDirectory/$dscBase" | jq -r 'to_entries[] | "_get " + (.key | @sh) + " " + (.value.bashValidate | @sh)')"
eval "$shell"
